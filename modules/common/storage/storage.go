package storage

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"time"

	"quel-canvas-server/modules/common/config"
	"quel-canvas-server/modules/common/database"
)

type Client struct {
	dbClient *database.Client
}

// NewClient - Storage í´ë¼ì´ì–¸íŠ¸ ìƒì„±
func NewClient(dbClient *database.Client) *Client {
	return &Client{
		dbClient: dbClient,
	}
}

// DownloadImageFromStorage - Supabase Storageì—ì„œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
func (c *Client) DownloadImageFromStorage(attachID int) ([]byte, error) {
	cfg := config.GetConfig()

	// 1. quel_attachì—ì„œ íŒŒì¼ ê²½ë¡œ ì¡°íšŒ
	attach, err := c.dbClient.FetchAttachInfo(attachID)
	if err != nil {
		return nil, err
	}

	// 2. attach_file_path í™•ì¸ (ì—†ìœ¼ë©´ attach_directory ì‚¬ìš©)
	var filePath string
	if attach.AttachFilePath != nil && *attach.AttachFilePath != "" {
		filePath = *attach.AttachFilePath
		log.Printf("ğŸ” Using attach_file_path: %s", filePath)
	} else if attach.AttachDirectory != nil && *attach.AttachDirectory != "" {
		filePath = *attach.AttachDirectory
		log.Printf("ğŸ” Using attach_directory: %s", filePath)
	} else {
		log.Printf("âŒ DB values - FilePath: %v, Directory: %v", attach.AttachFilePath, attach.AttachDirectory)
		return nil, fmt.Errorf("no file path found for attach_id: %d", attachID)
	}

	// 2.5. uploads/ í´ë”ê°€ ëˆ„ë½ëœ ê²½ìš° ìë™ ì¶”ê°€ (upload-ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš°)
	if len(filePath) > 0 && filePath[0] != '/' &&
	   len(filePath) >= 7 && filePath[:7] == "upload-" {
		filePath = "uploads/" + filePath
		log.Printf("ğŸ”§ Auto-fixed path to include uploads/ folder: %s", filePath)
	}

	// 3. Full URL ìƒì„±
	fullURL := cfg.SupabaseStorageBaseURL + filePath
	log.Printf("ğŸ“¥ Downloading image from: %s", fullURL)
	log.Printf("   ğŸ”— Base URL: %s", cfg.SupabaseStorageBaseURL)
	log.Printf("   ğŸ“ File Path: %s", filePath)

	// 4. HTTP GETìœ¼ë¡œ ì§ì ‘ ë‹¤ìš´ë¡œë“œ
	httpResp, err := http.Get(fullURL)
	if err != nil {
		log.Printf("âŒ HTTP GET failed: %v", err)
		return nil, fmt.Errorf("failed to download image: %w", err)
	}
	defer httpResp.Body.Close()

	if httpResp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(httpResp.Body)
		log.Printf("âŒ Download failed - Status: %d, URL: %s", httpResp.StatusCode, fullURL)
		log.Printf("âŒ Response body: %s", string(body))
		return nil, fmt.Errorf("failed to download image: status %d, body: %s", httpResp.StatusCode, string(body))
	}

	// 5. ì´ë¯¸ì§€ ë°ì´í„° ì½ê¸°
	imageData, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read image data: %w", err)
	}

	log.Printf("âœ… Image downloaded successfully: %d bytes", len(imageData))
	return imageData, nil
}

// UploadImageToStorage - Supabase Storageì— ì´ë¯¸ì§€ ì—…ë¡œë“œ (WebP ë³€í™˜ í¬í•¨)
func (c *Client) UploadImageToStorage(ctx context.Context, imageData []byte, userID string, convertToWebP func([]byte, float32) ([]byte, error)) (string, int64, error) {
	cfg := config.GetConfig()

	// PNGë¥¼ WebPë¡œ ë³€í™˜ (quality: 90)
	webpData, err := convertToWebP(imageData, 90.0)
	if err != nil {
		return "", 0, fmt.Errorf("failed to convert PNG to WebP: %w", err)
	}

	// íŒŒì¼ëª… ìƒì„± (WebP í™•ì¥ì)
	timestamp := time.Now().UnixNano() / int64(time.Millisecond)
	randomID := rand.Intn(999999)
	fileName := fmt.Sprintf("generated_%d_%d.webp", timestamp, randomID)

	// íŒŒì¼ ê²½ë¡œ ìƒì„±
	filePath := fmt.Sprintf("generated-images/user-%s/%s", userID, fileName)

	log.Printf("ğŸ“¤ Uploading WebP image to storage: %s", filePath)

	// Supabase Storage API URL
	uploadURL := fmt.Sprintf("%s/storage/v1/object/attachments/%s",
		cfg.SupabaseURL, filePath)

	// HTTP Request ìƒì„± (WebP ë°ì´í„° ì‚¬ìš©)
	req, err := http.NewRequestWithContext(ctx, "POST", uploadURL, bytes.NewReader(webpData))
	if err != nil {
		return "", 0, fmt.Errorf("failed to create upload request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+cfg.SupabaseServiceKey)
	req.Header.Set("Content-Type", "image/webp")

	// ì—…ë¡œë“œ ì‹¤í–‰
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", 0, fmt.Errorf("failed to upload image: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		body, _ := io.ReadAll(resp.Body)
		return "", 0, fmt.Errorf("upload failed with status %d: %s", resp.StatusCode, string(body))
	}

	webpSize := int64(len(webpData))
	log.Printf("âœ… WebP image uploaded successfully: %s (%d bytes)", filePath, webpSize)
	return filePath, webpSize, nil
}
